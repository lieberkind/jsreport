\chapter{Evaluation}

% Case study evaluation
\input{chapters/8-evaluation/evaluation-on-casestudy}

% Ease of use evaluation
\input{chapters/8-evaluation/evaluation-on-easeofuse}

% Implementation evaluation
\input{chapters/8-evaluation/evaluation-on-implementation}

\section{Reflection on Server Client Consistency} % (fold)
\label{sec:reflection_on_server_client_consistency}
	Server client side consistency is especially relevant when embedding JavaScript from Code Behind (section \ref{sub:client_side_scripts_code_behind}) as this gives no guarantees if the function you are calling exists. When using a regular JavaScript editor such a problem will usually be highlighted for you however nothing prevents you from trying to run broken scripts. Running broken scripts by mistake is less likely with MiCS. If there is not consistency between server and client side an exception will be thrown. This is obviously a benefit if correctness of the web application is critical.
% section reflection_on_server_client_consistency (end)

\section{Runtime vs Compile Time Errors} % (fold)
\label{sec:runtime_vs_compile_time_errors}
	Compile time errors are usually preferred over runtime errors as they are easier to resolve and hence less time consuming. Furthermore runtime errors are potentially exposed to the end user.  When using Script\# as originally intended one gets the benefit of having your code compile time validated in the same manner as when using C\#. This is an important reason for choosing a Script\# only solution for some projects (see section \ref{sec:when_to_use_mics}).

	Code will also be compile time validated when using MiCS there are however some errors that can now occur as runtime errors on server side. This can e.g. happen when unsupported C\# constructs are used (TODO: REF) or when the Mixed Side Principle (section \ref{sub:the_mixedside_principle}) is violated. This is as disadvantage of using MiCS when compared to a Script\# only solution. However this disadvantage is not critical as it is isolated to server side which implies that the end user can be exempt from being exposed to these errors. Furthermore the server side runtime errors will still prevent a web application from running in a corrupt state (section \ref{ssub:server_client_consistency}). 

% section runtime_vs_compile_time_errors (end)

\section{Reflection on Mixed Side Code} % (fold)
\label{sec:reflection_on_mixed_side_code}
	Benefits to mixed side code are that existing server side code can easily be used for client side as well. So if you already have server side validation code it will work for client side as well which is obviously a great benefit as it can potentially safe you lots of time. Additionally when writing new code you will only have to write e.g. validation code once and therefore also only write tests once, which can obviously also safe you lots of time. This way Unit testing frameworks for server side will essentially be testing some of your client side code (i.e. mixed side code).

	One cost of mixed side code is that some compile time errors will become (server side) runtime errors as discussed in section \ref{sec:runtime_vs_compile_time_errors}. Another cost of mixed side code is that it can only contain C\# constructs that can be mapped to JavaScript. However this might not be that big a problem as most C\# constructs can be mapped to JavaScript. It might though in rare occasions limit the reuse of existing code or new mixed side code. However in most situations (see section \ref{sec:when_to_use_mics}) we find that the benefits outweighs the cost.

% section reflection_on_mixed_side_code (end)

\section{When to Use MiCS} % (fold)
\label{sec:when_to_use_mics}
	When choosing to use MiCS or a different safe JavaScript approach it’s beneficial to consider if one’s application is client side heavy, server side heavy or both. Using Script\# in the original manner would be a good approach to a client side heavy application as it will reveal the most errors at compile time. 

	If you have an application that is both client side heavy and server side heavy using MiCS might be a good choice as it gives you the additional benefits of ‘server client portability’ and ‘server client consistency’. The cost is that some of your compile time errors will become runtime errors (on server side) but this doesn’t necessary outweigh the other benefits. 

	If you have a web application that is server side heavy you might not use any framework for safe JavaScript development or you could use MiCS as the over head would be low and it would give some additional guarantees of correctness.

	Another thing to consider when deciding to use MiCS is the likelihood of the server side implementation to change from ASP.NET Web Forms. When using MiCS the JavaScript is written on server side. If the server side implementation is to change, the JavaScript generated by MiCS has to be implemented ``manually'' (note that this also applies to the HTML pages generated from Code Behind). Using ASP.NET Web Form and MiCS creates a completely compile time validated web application, however, the coupling between the server and the client is very tight.

% section when_to_use_mics (end)


\section{Safety Benefits vs. Convenience} % (fold)
\label{sec:safety_benefits_vs_conveniente}
	Safety in development is the main target of this project however safety always comes at a cost. Unsafe JavaScript development can be done very fast and even though we think we have a solution to safe JavaScript development with very little over head unsafe JavaScript can be the right choice for some projects. However if a project reach a certain size or complexity (and if correctness matters) it will eventually be beneficial to use JavaScript in safe manner.

% section safety_benefits_vs_conveniente (end)
\section{Future Work}
\begin{itemize}
	\item Todo: Inheritance
	\item Todo: Portability of Server Side values
	\item Todo: Improve tests and guarantee of MiCS correctness in general as MiCS correctness should be considered critical as web apllications are built onto MiCS...
\end{itemize}