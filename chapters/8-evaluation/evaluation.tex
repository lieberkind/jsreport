\chapter{Evaluation}

% Case study evaluation
\input{chapters/8-evaluation/evaluation-on-casestudy}

\section{Ease of Use} % (fold)
\label{sec:ease_of_use}

	\begin{itemize}
		\item Elaborate on the user friendliness of error messages, why they are important
		and to which degree we have implemented them.
		\item Indlæringskurve. Tungen lige i munden. Client-Server confusion
	\end{itemize}
% section ease_of_use (end)

% Implementation evaluation
\input{chapters/8-evaluation/evaluation-on-implementation}

\section{Reflection on Server Client Consistency} % (fold)
\label{sec:reflection_on_server_client_consistency}
	Server client consistency is especially relevant when embedding JavaScript as text strings in ASP.NET Web Forms as this gives no guarantees if the function you are calling exists. When using a regular JavaScript editor such a problem will usually highlighted for you however nothing usually prevents you from trying to run your broken JavaScript. This is not possible with MiCS. If there is not consistency between server and client side an exception will be thrown. This is obviously a benefit especially if correctness of the web application is critical.
% section reflection_on_server_client_consistency (end)

\section{Runtime vs Compile Time Errors} % (fold)
\label{sec:runtime_vs_compile_time_errors}

% section runtime_vs_compile_time_errors (end)

\section{Reflection on Mixed Side Code} % (fold)
\label{sec:reflection_on_mixed_side_code}
	Benefits to mixed side code are that existing server side code can easily be used for client side as well. So if you already have server side validation code it will work for client side as well which is obviously a great benefit as it can potentially safe you lots of time. Additionally when writing new code you will only have to write e.g. validation code once and therefore also only write tests once, which can obviously also safe you lots of time. This way Unit testing frameworks for server side will essentially be testing some of your client side code (i.e. mixed side code).

	One cost of mixed side code is that some compile time errors will become (server side) runtime errors as discussed in section \ref{sec:runtime_vs_compile_time_errors}. Another cost of mixed side code is that it can only contain C\# constructs that can be mapped to JavaScript. However this might not be that big a problem as most C\# constructs can be mapped to JavaScript. It might though in rare occasions limit the reuse of existing code or new mixed side code. However in most situations (see section \ref{sec:when_to_use_mics}) we find that the benefits outweighs the cost.

% section reflection_on_mixed_side_code (end)

\section{When to Use MiCS} % (fold)
\label{sec:when_to_use_mics}
	When choosing to use MiCS or a different safe JavaScript approach it’s beneficial to consider if one’s application is client side heavy, server side heavy or both. Using Script\# in the original manner would be a good approach to a client side heavy application as it will reveal the most errors at compile time. 

	If you have an application that is both client side heavy and server side heavy using MiCS might be a good choice as it gives you the additional benefits of ‘server client portability’ and ‘server client consistency’. The cost is that some of your compile time errors will become runtime errors (on server side) but this doesn’t necessary outweigh the other benefits. 

	If you have a web application that is server side heavy you might not use any framework for safe JavaScript development or you could use MiCS as the over head would be low and it would give some additional guarantees of correctness.

% section when_to_use_mics (end)


\section{Safety Benefits vs. Convenience} % (fold)
\label{sec:safety_benefits_vs_conveniente}
	Safety in development is the main target of this project however safety always comes at a cost. Unsafe JavaScript development can be done very fast and even though we think we have a solution to safe JavaScript development with very little over head unsafe JavaScript can be the right choice for some projects. However if a project reach a certain size or complexity (and if correctness matters) it will eventually be beneficial to use JavaScript in safe manner.

% section safety_benefits_vs_conveniente (end)
\section{Future Work}
\begin{itemize}
	\item Inheritance
	\item Portability of Server Side values
\end{itemize}