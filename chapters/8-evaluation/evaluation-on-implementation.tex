\section{Reflection on Implementation} % (fold)
\label{sec:reflection_on_implementation}
This section will focus on the implementation of MiCS and will mainly point out things that should be improved, and how improvements can be implemented.


\subsection{Validation} % (fold)
\label{ssub:validation}
% TODO: Should this be mentioned? It is necessary to make sure that developer only uses C\# constructs (method declarations, various statements and expressions, etc.) that we can correctly map to Script\#. At the moment, this is handled by the Builder classes, and will be explained in a later section. However, optimally this should be the responsibility of the Validator class. How this can be achieved is described in future work.

As explained in section \ref{sec:syntax_tree_validation}, when validating the Roslyn AST a structure of members is used to determine whether calls to types or methods defined by the developer are valid. This also applies to calls on DOM types and methods. While this solution works for our case study, it might not be appropriate as MiCS grows. Instead, the validator should make use of the Semantic Model on the \texttt{CSharpTypeManager} to look up types and methods. All the information that MiCS needs to decide whether the call is legal or not can be obtained from the semantic model. Furthermore, as the semantic model is automatically generated by Roslyn, it doesn't need to be maintained as MiCS grows which is not the case with the \texttt{Collector} class, that currently holds the responsibility for generating the members structure.
% subsection validation (end)

\subsection{Integration with Web Forms} % (fold)
\label{ssub:integration_with_web_forms}
Todo
% subsection integration_with_web_forms (end)

\subsection{Initializing MiCS} % (fold)
\label{ssub:collecting_source_code}
When MiCS is initialized, all the developer's source code files are iterated and concatenated into a single string from which the Roslyn AST is built. Roslyn interprets this string as a single source file and builds the AST accordingly which is not optimal as \texttt{using} statements should always be the first statements of a C\# source file. Consequently, only the \texttt{using} statements from the first file will be registered as being valid and all others are simply ignored. To overcome this, the necessary \texttt{using} statements for our case study are at the moment hardcoded into the beginning of the Roslyn AST. The solution to this problem is simply to generate a Roslyn AST for each of the developer's source files. This, of course, would require MiCS to validate all of these syntax trees, map them all to Script\#. Apart from correctness, a benefit of having multiple ASTs would allow for. the validation and mapping to Script\# to happen in parallell, e.g. one thread per AST.
% subsection collecting_source_code (end)

\subsection{Extendability} % (fold)
\label{sub:extendability}
At the moment, MiCS is implemented with our case study in mind. Only the C\# constructs and types needed to fulfill the requirements set by the case study are supported. However, MiCS is easily extended to support additional statements, expressions or other constructs. For example, if a \texttt{while}-statement was to be supported, only two classes would have to be extended; the \texttt{StatementBuilder} and \texttt{StatementMapper} classes. In the \texttt{StatementMapper} class, an extension method to Roslyn's \texttt{WhileStatementSyntax} would have to be implemented in order to map the Roslyn while-statement to a Script\# while-statement. In the \texttt{StatementBuilder} class, the \texttt{VisitWhileStatement} method (inherited from Roslyn's \texttt{SyntaxWalker} class) would have to be overwritten in order to start the mapping, and add the while-statement to the Script\# AST.

To add support for a new C\# core type, e.g. the \texttt{Date} type, all that is needed is to add a new entry in the \texttt{MiCSCoreMapping}-specification, as explained in section \ref{subsub:core:type_mapping}
% subsection extendability (end)

% section reflection_on_implementation (end)