\chapter{Background}

\section{ASP.NET Web Forms} % (fold)
\label{sec:asp_net_web_forms}
	% Todo: explain Active Server Pages
	ASP.NET. Web Forms are the User Interface (UI) elements that give your Web applications their look and feel. Web Forms are similar to Windows Forms \cite{msdn01} in that they provide properties, methods, and events for the controls that are placed onto them. However, these UI elements render themselves into Html \cite{msdn02}. When working with Web Forms you can both write markup code and write C\# code from Code Behind (explained in \ref{sub:code_behind}) when building a web application. 

	\begin{figure}[H]
					\includegraphics[width=8cm]{resources/images/Markup.png}
				\caption{Markup code in Default.aspx}
				\label{markup}
			\end{figure}

	\subsection{Code Behind} % (fold)
	\label{sub:code_behind}
		The web page Default.aspx is associated to a C\# file, Default.aspx.cs, where the page has different events that can be utilized. This is \texttt{Default.aspx}'s \emph{Code Behind} file. In figure \ref{codeBehind} a button control is added to the form \texttt{form1} (defined in markup in figure \ref{markup}) via the page’s Load event. This is opposed to adding the button in markup code.


				\begin{figure}
					\includegraphics[width=10cm]{resources/images/CodeBehind.png}
				\caption{Default.aspx.cs Code Behind file associated to the Default.aspx page.}
				\label{codeBehind}
			\end{figure}
		The resulting web page and source will be as shown in figure \ref{html} (with Chrome Development Tools).

				\begin{figure}
					\includegraphics[width=12cm]{resources/images/Html.png}
				\caption{Resulting web page and source code of the Default.aspx page.}
				\label{html}
			\end{figure}
		There are built-in control classes equivalent to most DOM elements so in this manner one can build an entire web application from Code Behind. Some of the benefits of working from Code Behind is that you essentially achieve compile time validation of your markup code and you get to work in object oriented manner.

		todo: Web Forms unsafe JavaScript example.
	% subsection code_behind (end)

% section asp_net_web_forms (end)

\section{JavaScript and its Unsafe Language Features} % (fold)
\label{sec:javascript_and_its_unsafe_language_feature}
	
	JavaScript is an interpreted, dynamically typed scripting language used mainly for making web applications with dynamic user interfaces. JavaScript inherits its syntax from C, and was developed by Netscape in 1995 \cite{bib:wiki_javascript}. Today, JavaScript is used in almost all big web applications, but despite its popularity, it has some language features that can be considered unsafe when correctness is of high priority. The remainder of this section will highlight some of these unsafe language features.

	\subsection{No compile time validation} % (fold)
	\label{sub:no_compile_time_validation}
		In general enforcing correctness at compile time instead of runtime makes the development process safer as some errors (e.g.\ syntax errors like missing semicolons) are not possible to overlook or ignore. Furthermore discovering errors as early as possible makes the debugging process easier hence compile time errors should be preferred over runtime errors. So the fact that JavaScript is an interpreted language that is not compiled makes it a less safe language.
	% subsection no_compile_time_validation (end)

	\subsection{Dynamic type system} % (fold)
	\label{sub:dynamic_type_system}
		JavaScript has a dynamic type system which in some situations make the development process faster but also less safe as some errors will not emerge at all (or maybe emerge at runtime). E.g. it is possible to by mistake add a Number value with a Boolean value without getting any warnings. In other words it is possible to forget enforcing that a variable has a specific type. This problem is amplified when parsing external input as it is done e.g.\ in form validation.
	% subsection dynamic_type_system (end)

	\subsection{Reuse of identifiers in declarations} % (fold)
	\label{sec:reuse_of_identifiers_in_declarations}
		JavaScript allows declaring multiple variables or functions with the same name in the same execution context without any warnings. This makes it possible by mistake to override earlier declared variables or functions. This kind of errors can be difficult and time consuming to discover because of their hidden nature.
	% section reuse_of_identifiers_in_declarations (end)

	\subsection{No block scope} % (fold)
	\label{sub:no_block_scope}
		JavaScript's syntax comes from C. In all other C-like languages a block creates scope. This is not the case in JavaScript even though its block syntax suggests that it does (“The Good Parts” p. 102). This can be a source of confusion especially for programmers that are used to block scope. Scope related errors might be difficult to debug as obviously no warnings are given (since there is no block scope) when a variable from an outer block is assigned a value by mistake.
	% subsection no_block_scope (end)

	\subsection{Implicit Type Conversion} % (fold)
	\label{sub:implicit_type_conversion}
	TODO
	% subsection implicit_type_conversion (end)

	\subsection{Many ''falsy'' values} % (fold)
	\label{sub:many_falsy_values}
		TODO: Clarify this
		JavaScript has multiple falsy values which are not interchangeable. This is another source of errors that can be difficult to discover (“The Good Parts” p. 106).
	% subsection many_falsy_values (end)
% section javascript_and_its_unsafe_language_feature (end)

\section{Related works} % (fold)
\label{sec:related_works}
TODO
% section related_works (end)

