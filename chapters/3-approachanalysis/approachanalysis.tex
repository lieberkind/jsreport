\chapter{Approach Analysis}
	As mentioned in the problem definition, it was decided to conduct an analysis in order to find out which approach would best fit this project. This chapter will give an overview of different technologies we have considered to use and describe how they can be used in combination to approach the project in different ways. Lastly, a comparison of the approaches will be made, in order to decide on which approach to implement.

\section{Useful Technologies}
	This section introduces the different technologies considered useful to this project. Script\# and Microsoft Roslyn will be described in detail, as they were eventually chosen for the implementation of MiCS.

	\input{chapters/3-approachanalysis/technologies-roslyn}

	\subsection{Script\#} % (fold)
	\label{sub:subsection_scriptsharp}
		Script\# \cite{scriptsharp} is a cross-compiler from C\# to JavaScript that is maintained by Nikhil Kothari \cite{nikhilk} from Microsoft. Script\# works by compiling an entire C\# project to JavaScript. Script\# is interesting for several reasons; it contains an AST-representation of JavaScript in C\# and a way to generate JavaScript source code from this AST. Furthermore, it contains a C\# representation of the DOM (Document Object Model).

		The main assembly, ScriptSharp.dll, is shown in figure \ref{simplifiedOverview} as a simplified dependency diagram. When Script\# is used in a regular manner, an AST representing C\# source code is built using classes from the Parser and CodeModel namespaces. The ScriptModel namespace contains classes which represent the different nodes in the JavaScript AST. The actual JavaScript source is generated using classes in the Generator namespace. Another important assembly is the Script.Web.dll which contains classes for DOM representation.

		\begin{figure}[H]
			\begin{center}
				\centerline{\includegraphics[width=16cm]{resources/images/SimplifiedOverview.png}}
			\end{center}
			\caption{Simplified Script\# architecture overview (dependency diagram).}
			\label{simplifiedOverview}
		\end{figure}


		A thing unique to Script\# is that it defines a modified version of the .NET mscorlib.dll (also shown in figure \ref{simplifiedOverview}) that modifies the .NET core type interfaces to resembles their equivalent JavaScript objects. E.g. the Script\# defined System.String type has a \texttt{CharAt(int index)} function that doesn't exist on the original .NET System.String type but \emph{does} exist on the JavaScript String object. One benefit of the modified mscorlib.dll is that it makes the C\# compiler able to validate the C\# code that represents JavaScript. However, \emph{evaluating} C\# code that uses these modified .NET types will never make sense, as all of the methods and fields on them either returns null, 0, or false, as shown in figure \ref{fig:scriptsharp_net_types}. This implies that the Script\# modified core types can only be used for JavaScript generation.

		\begin{figure}
		\label{fig:scriptsharp_net_types}
			\begin{lstlisting}[language=CSharp,classoffset=1,morekeywords={String}]
namespace System {

  /// <summary>
  /// Equivalent to the String type in Javascript.
  /// </summary>
  [ScriptIgnoreNamespace]
  [ScriptImport]
  public sealed class String {

    ...

    /// <summary>
    /// The number of characters in the string.
    /// </summary>
    [ScriptField]
    public int Length {
      get {
        return 0;
      }
    }

    ...

    /// <summary>
    /// Encodes a single part or component of a URI.
    /// </summary>
    /// <returns>The encoded string.</returns>
    [ScriptAlias("encodeURIComponent")]
    public string EncodeUriComponent() {
      return null;
    }

    ...
  }
}

			\end{lstlisting}
			\caption{Properties and methods on Script\#'s String type}
		\end{figure}

		In short the modified mscorlib.dll file is referenced in one's Visual Studio project (instead of the original one) when a new Script\# project is created. When a Script\# project is compiled a JavaScript file will be generated. This JavaScript file can then be used in other projects (E.g. a Web Forms web application). The C\# source code will not be evaluated.
	% subsection subsection_name (end)


	% \subsection{Microsoft Roslyn} % (fold)
	% \label{ssub:microsoft_roslyn}

	% % subsection microsoft_roslyn (end)

	\subsection{Code Quotations} % (fold)
	\label{ssub:code_quotations}
		Code Quotations is a built-in feature in the F\# language which lets a developer generate an abstract syntax tree that represents the corresponding F\# code. Code Quotations cover the entire F\# language, meaning that theoretically all F\# constructs can be mapped to a corresponding JavaScript construct.

	% subsection code_quotations (end)

	\subsection{Expression Trees} % (fold)
	\label{ssub:expression_trees}
			Expression Trees is a built-in feature in the C\# (and Visual Basic) language that “represents code in a tree-like data structure, where each node is an expression, for example, a method call or a binary operation” (REF MSDN). Expression Trees are often used with LINQ to build dynamic queries, which can be useful when fetching data from a database with filters specified by the user (these filters may be provided through a user interface). Expression Trees can be generated from lambda expressions, and thus it is possible to retrieve a representation of simple pieces of code, such as the following:

			\begin{lstlisting}[language=CSharp,classoffset=1,morekeywords={Func}]
				Func<int, int, bool> function = (a, b) => a > b
			\end{lstlisting}

			or more sophisticated ones such as LINQ queries. 
	% subsection expression_trees (end)

	\subsection{Internal DSL} % (fold)
	\label{ssub:internal_dsl}
		There are different approaches to writing a Domain Specific Languages (DSL) with Internal DSLs you work in your regular language and is therefore also constraint by this language and its features \cite{domain_specific_languages}. Another term for Internal DSL is fluent interface who's central pattern is that of method chaining which is the pattern we somewhat investigated for the use of safe JavaScript representation. In our case we aimed for a Internal DSL that would somewhat the C-like syntax of JavaScript.
	% subsection internal_dsl (end)

\section{Stages When Going From .NET Language to JavaScript} % (fold)
\label{sec:stages_when_going_from_net_language_to_javascript}
	Before discussing different approaches it makes sense to clarify the possible stages in the process of going from a .NET language to JavaScript. The process (displayed in figure \ref{stages}) moves from left to right. Different approaches use different stages.

				\begin{figure}[H]
			\begin{center}
				\centerline{\includegraphics[width=14cm]{resources/images/stages.png}}
			\end{center}
			\caption{Possible approach stages}
			\label{stages}
		\end{figure}

	 From concrete syntax a C\# or F\# abstract syntax tree (AST) can be generated. This AST can be traversed in order to map it to a JavaScript AST. Finally, JavaScript can be generated from the JavaScript AST.
% section stages_when_going_from_net_language_to_javascript (end)

\input{chapters/3-approachanalysis/possible-approaches.tex}

\section{TODO: Deciding on Approach} % (fold)
\label{sec:deciding_on_approach}
	In the previos sections we have described varios technologies, how they can be used in combination to form approaches, and some of the benefits and disadvantages of these approaches. To make a final decission on which approach to choose for implementation, an approach matrix has been made. The matrix evaluates the different approaches based on 9 different critera. The approach matrix is shown in figure \ref{approachMatrix}, and below each criterion is explained.

	\begin{figure}
		\begin{center}
			\centerline{\includegraphics[width=16cm]{resources/images/approachmatrix.eps}}
		\end{center}
		\caption{Approach Matrix.}
		\label{approachMatrix}
	\end{figure}

	\begin{itemize}
		\item \textbf{Server Client Portability} The ability to generate JavaScript from working server side code
		\item \textbf{Ease of Use} How easy the approach is to use for the developer
		\item \textbf{Compile Time Errors} Amount of errors this approach will catch on compile time
		\item \textbf{AST Benefits} How easily AST the developer's code can be converted to an AST
		\item \textbf{Consise Syntax} How concise the syntax of the approach will be
		\item \textbf{Existing Infrastructure} The degree to which the approach makes use of existing C\# or F\# constructs
		\item \textbf{Experience with .NET Language} How well we know the language in which the approach is implemented
		\item \textbf{Ease of Unit Testing} How easily the developer can unit test his code with the approach
	\end{itemize}

	\FloatBarrier

	\subsection{MiCS: Mixed Side C\#} % (fold)
	\label{sub:mics_mixed_side_csharp}
	MiCS will use Roslyn and Script\# in combination. Roslyn will be used to generate an AST representing the developer's C\# source code. The core functionality of MiCS will be to map this generated AST to a Script\# JavaScript AST. Script\#'s JavaScript generator will be used to generate the actual JavaScript source code, and a method to inject the source code into the developer's web application will be implemented.

	TODO: Skal uddybes
	% subsection mics_mixed_side_csharp (end)

	\subsection{TODO: Detailed Scope} % (fold)
	\label{sub:detailed_scope}
	
		\begin{itemize}
			\item Only methods are supported
		\end{itemize}

	% subsection detailed_scope (end)
% section deciding_on_approach (end)