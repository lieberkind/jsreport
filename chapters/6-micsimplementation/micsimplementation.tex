\chapter{MiCS Implementation}
	... indledning ...


\section{Types in MiCS} % (fold)
\label{sec:types_in_mics}
	To help understand the core type validation and MiCS type mapping in general its beneficial to realise the different kind of types that are utilized in MiCS.

	\begin{figure}[H]
		\begin{center}
			\centerline{\includegraphics[width=16cm]{resources/images/TypesOverview.png}}
		\end{center}
		\caption{Illustrates the different types used by MiCS.}
		\label{typesOverview}
	\end{figure}

	Since one of the goals of MiCS is to be able to execute the same code on both client and server side (server client portability) its required that the .NET core types are used when writing MiCS code. This is in contrast to how Script\# works in its original manner where the Script\# core types (that reflect the equivalent JavaScript types) are used. This has some benefits but is also an obstacle that prevents server client portability.

	\subsection{Core Types} % (fold)
	\label{sub:core_types}
		To build the ScriptSharp AST correctly the ScriptSharp core types are required to be associated to the AST nodes. One reason why the ScriptSharp core types are required is that they define their equivalent script name (in the class attributes) that is used by the ScriptSharp script generator. An example is the System.Char (see figure \ref{char}) type which is converted to the JavaScript String type as no JavaScript Char type exists.

	\begin{figure}[H]
			\includegraphics[width=13cm]{resources/images/Char.png}
		\caption{The core type System.Char defined in the Script\# mscorlib.dll.}
		\label{char}
	\end{figure}

		MiCS utilizes the regular .NET core types when a user is writing MiCS code but when generating the client side script the Script\# defined core types are used. This implies that some kind of mapping between the two kinds of core types are required. This mapping of core types is explained in section \ref{sub:type_mapping}.
	% subsection core_types (end)

	\subsection{User Types} % (fold)
	\label{sub:user_types}
		User types are the types that are defined by the MiCS end user. The user types considered here are either MixedSide types or ClientSide types (i.e. types that have method members that have the either the MixedSide attribute or the ClientSide on them). User type definitions is what the generated client side script eventually will consist of. 

		Pure server side types are obviously also user types but they are not that relevant in a MiCS context and therefore not discussed here.
	% subsection user_types (end)

	\subsection{DOM Types} % (fold)
	\label{sub:dom_types}
		Document Object Model (DOM) types are Script\# infrastructure defined in the System.Html namespace (Script.Web.dll). These classes that represent DOM objects from the browser. The purpose of these classes is only to represent the interface of the actual DOM types in the browser. This is also seen if one looks at the implementation of these types as all their methods and properties on these types return null or false. Like the Script\# core types, DOM types also has their script names in the attribute [ScriptName]. The DOM types are only meant for ClientSide code.

		\begin{figure}[H]
				\includegraphics[width=7cm]{resources/images/Document.png}
			\caption{Script\# definition of the DOM type Document.}
			\label{fig:document}
		\end{figure}
	% subsection dom_types (end)

% section types_in_mics (end)

\input{chapters/6-micsimplementation/initializing-mics}

\input{chapters/6-micsimplementation/syntaxtreevalidation}

\section{Mapping to ScriptSharp AST} % (fold)
\label{sec:mapping_to_scriptsharp_ast}
	When converting the validated Roslyn AST to the ScriptSharp AST we have made a logical division of the process. First the actual mapping from one Roslyn AST node to the equivalent ScriptSharp AST node. Secondly building the ScriptSharp AST from all the mapped nodes. The mapping is discussed in this section. 

	\subsection{Mapping to ScriptSharp Expressions, Statements and Symbols} % (fold)
	\label{sub:subsection_mapping_to_scriptsharp_expressions_statements_and_symbols}
		The mapping of Expressions, Statements and Symbols is implemented in three classes (ExpressionMapper.cs, StatementMapper.cs and SymbolMapper.cs). The three classes are logically divided (and named) after the type of ScriptSharp AST object they map to. 

		\begin{figure}[H]
			\begin{center}
				\centerline{\includegraphics[width=14cm]{resources/images/MapperClasses.png}}
			\end{center}
			\caption{Classes that define extension methods for mapping Roslyn AST nodes to Script\# AST nodes.}
			\label{mapperClasses}
		\end{figure}

		The mapping of the AST nodes is somewhat straightforward as most of the mappings we have done the Roslyn AST maps one to one with the ScriptSharp AST. So a Roslyn return statement node maps to a ScriptSharp return statement etc. The three classes define Map(...) extension methods to the Roslyn objects they map from (see example figures \ref{returnStatementMap} and \ref{conditionaleExpressionMap}).

		\begin{figure}[H]
			\begin{center}
				\centerline{\includegraphics[width=14cm]{resources/images/ReturnStatementMap.png}}
			\end{center}
			\caption{Extension method that maps Roslyn return statement to Script\# return statement.}
			\label{returnStatementMap}
		\end{figure}

		\begin{figure}[H]
			\begin{center}
				\centerline{\includegraphics[width=14cm]{resources/images/ConditionalExpressionMap.png}}
			\end{center}
			\caption{Extension method that maps Roslyn conditional expression to Script\# conditional expression.}
			\label{conditionaleExpressionMap}
		\end{figure}
	% subsection subsection_mapping_to_scriptsharp_expressions_statements_and_symbols (end)

	\subsection{Type Mapping} % (fold)
	\label{sub:type_mapping}
		Roslyn type symbols are mapped to Script\# type symbols using the SymbolMapper’s Map(...) extension method created for the Roslyn TypeSymbol. The mapping of TypeSymbols from Roslyn to Script\# can be somewhat confusing since there are the different kinds of types (illustrated in figure \ref{typesOverview}) and there are some special cases (such as null which is mapped to the type Object in JavaScript). To illustrate the functionality of the TypeSymbol Map(...) method we have created the flowchart in figure \ref{typeMappingFlowchart}.

			\begin{figure}
			\begin{center}
					\includegraphics[width=14cm]{resources/images/TypeMappingFlowchart.png}
					\end{center}
				\caption{Illustration of the type mapping process performed in SymbolMapper.Map(this TypeSymbol typeSymbol) extension method.}
				\label{typeMappingFlowchart}
			\end{figure}


		\subsubsection{Core Type Mapping} % (fold)
		\label{subsub:core:type_mapping}
			In contrast to using Script\# in the original manner (where the Script\# core types are used when writing code instead of the .NET core types) our project only uses the Script\# core types when mapping to the Script\# JavaScript AST. For this reason the Script\# core types are handled by its own type manager class (ScriptSharpTypeManager.cs). The Script\# core types’ source code are loaded into their own SemanticModel on the TypeManager class. From here the (Roslyn) types are retrieved before they are mapped to Script\# TypeSymbols needed when building the Script\# AST.

			Since the .NET core types are used when writing MiCS code and since these are mapped to the ScriptSharp core types a mapping specification is needed. To facilitate this mapping we have created some simple classes to hold the specification (MiCSCoreMapping.cs, MiCSCoreTypeMapping.cs and MiCSCoreMemberMapping.cs) which then can queried using LINQ. This mapping specification contains information on the core types that we currently support. So if a core type is not described in the specification then it is not supported. If the core type is found in the specification then the same pattern applies for its members. If a type member is not found then it is not supported. The mapping specification also holds information on a member’s return type, number of arguments and the arguments’ types.

			\begin{figure}[H]
					\includegraphics[width=8cm]{resources/images/InitiationOfTypeMapping.png}
				\caption{Instantiation example of a single core type (System.String) mapping specification.}
				\label{coreTypeMapping}
			\end{figure}

			An example of a core type mapping is the C\# System.String (see figure \ref{coreTypeMapping}) type which is mapped to the ScriptSharp defined System.String. We are only mapping two of the String type’s members. The field Length which is mapped to the ScriptSharp String type’s Length field (which is the equivalent of the JavaScript String object property length). The second member we map is the IndexOf(Char char) method that returns an int. There are other IndexOf methods that take multiple arguments or a single argument of a different type (than Char) but these are not mapped in our mapping specification.
		% subsection subsection_name (end)
	% subsection type_mapping (end)
% section mapping_to_scriptsharp_ast (end)

\section{Building the ScriptSharp AST} % (fold)
\label{sec:building_the_scriptsharp_ast}
	Building the Script\# AST consists of taking the mapped (Script\#) AST nodes and putting them together to form the Script\# AST. The builder classes utilize the Roslyn infrastructure by extending the SyntaxWalker class which makes them capable of traversing the Roslyn AST.
	\begin{figure}[H]
		\begin{center}
			\centerline{\includegraphics[width=16cm]{resources/images/BuilderClasses.png}}
		\end{center}
		\caption{Classes that built the Script\# AST by traversing the Roslyn AST and utilizing Map(...) extension methods.}
		\label{builderClasses}
	\end{figure}

	The NamespaceBuilder class is responsible for building all of its defined types. This is done by instantiating a ClassBuilder which in turn is responsible for building all of its member methods (which is done by instantiating a MethodBuilder). This implies that the building of the Script\# AST is done in a depth first manner. The NamespaceBuilder and ClassBuilder classes are somewhat trivial. 

	\begin{figure}[H]
		\begin{center}
			\centerline{\includegraphics[width=16cm]{resources/images/VisitClassDeclaration.png}}
		\end{center}
		\caption{Empty Script\# class is created and then built by using a MethodBuilder to retrieve all its member methods. The ssClasses property on the class builder holds all the classes that will be returned to the NamespaceBuilder who created it.}
		\label{visitClassDeclaration}
	\end{figure}

	The ClassBuilder has an important feature; it ensures that only user defined types will be mapped to the Script\# AST (and generated as script types). DOM (or core) types doesn’t need to be defined in Script\# as these obviously already exists in JavaScript (and thus not need to be generated again).

	The MethodBuilder class is a little more complex as it needs to build only the methods that are MixedSide or ClientSide methods. Furthermore it needs to handle a method’s return type, arguments and body statements. The StatementBuilder and ExpressionBuilder is however the most complex as building compound statements and expressions are more complicated. Before a compound statement or expression can be build all the child nodes and their associated types (if any) needs to be mapped.

	\begin{figure}[H]
		\begin{center}
			\centerline{\includegraphics[width=16cm]{resources/images/VisitIfStatement.png}}
		\end{center}
		\caption{To built an IfStatement node its child nodes; condition, if-block and else-block (if any) has to be built first.}
		\label{visitIfStatement}
	\end{figure}

	When a builder class is done building the node(s) are returned to the parent builder class. Once all the namespaces has been built these constitute the Script\# AST which is then passed on in the overall workflow (to script generation).
% section building_the_scriptsharp_ast (end)

\section{Script Generation} % (fold)
\label{sec:script_generation}
	Script generation is done using the ScriptSharp infrastructure only. Specifically the TypeGenerator class located in the ScriptSharp.Generator namespace is utilized for this. The MiCSManager is responsible for instantiating the TypeGenerator and providing it with the ScriptSharp JavaScript AST type nodes (this happens in the MiCSManager.GenerateScriptText method). The ScriptSharp JavaScript AST consists only of the user defined script types.
% section script_generation (end)

\section{Integration with Web Forms} % (fold)
\label{sec:integration_with_web_forms}
	sdsadq qdqw qwd qwd qw 
% section integration_with_web_forms (end)
