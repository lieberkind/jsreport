\chapter{MiCS Implementation}
	In this chapter, the implementation of MiCS will be described. It will start out by discussing the different types that can be used in MiCS and then describe each of the five stages when generating JavaScript from C\# as explained in section \ref{sec:workflow_overview}. For clarity purposes, the third stage (Building + Mapping to Script\# AST) is divided into two different sections.


\section{Types in MiCS} % (fold)
\label{sec:types_in_mics}
	To help understand the core type validation and MiCS type mapping in general its beneficial to realise the different kind of types that are utilized in MiCS.

	\begin{figure}[H]
		\begin{center}
			\centerline{\includegraphics[width=16cm]{resources/images/TypesOverview.png}}
		\end{center}
		\caption{The different types used by MiCS.}
		\label{typesOverview}
	\end{figure}

	Since one of the goals of MiCS is to be able to execute the same code on both client and server side (server client portability) its required that the .NET core types are used when writing MiCS code. This is in contrast to how Script\# works in its original manner where the Script\# core types (that reflect the equivalent JavaScript types) are used. This has some benefits but is also an obstacle that prevents server client portability.

	\subsection{Core Types} % (fold)
	\label{sub:core_types}
		To build the ScriptSharp AST correctly the ScriptSharp core types are required to be associated to the AST nodes. One reason the ScriptSharp core types are required is that they define their equivalent script name (in the class attributes) that is used by the ScriptSharp script generator. An example is the System.Char (see figure \ref{char}) type which is converted to the JavaScript String type as no JavaScript Char type exists.

	\begin{figure}[H]
			\includegraphics[width=13cm]{resources/images/Char.png}
		\caption{The core type System.Char defined in the Script\# mscorlib.dll.}
		\label{char}
	\end{figure}

		MiCS uses the regular .NET core types when a developer is writing MiCS code but when generating the client side script the Script\# defined core types are used. This implies that some kind of mapping between the two kinds of core types are required. This mapping of core types is explained in section \ref{sub:type_mapping}.
	% subsection core_types (end)

	\subsection{User Types} % (fold)
	\label{sub:user_types}
		User types are the types that are defined by the developer. The user types considered here are either MixedSide types or ClientSide types (i.e. types that have method members that have the either the MixedSide attribute or the ClientSide on them). User type definitions is what the generated client side script eventually will consist of. 

		Pure server side types are obviously also user types but they are not relevant in a MiCS context as JavaScript will not be generated from them.
	% subsection user_types (end)

	\subsection{DOM Types} % (fold)
	\label{sub:dom_types}
		Document Object Model (DOM) types are Script\# infrastructure defined in the System.Html namespace (Script.Web.dll). These classes that represent DOM objects from the browser. The purpose of these classes is only to represent the interface of the actual DOM types in the browser. This is also seen if one looks at the implementation of these types as all their methods and properties on these types return null or false. Like the Script\# core types, DOM types also has their script names in the attribute [ScriptName]. The DOM types are only meant for ClientSide code.

		\begin{figure}[H]
				\includegraphics[width=7cm]{resources/images/Document.png}
			\caption{Script\# definition of the DOM type Document.}
			\label{fig:document}
		\end{figure}
	% subsection dom_types (end)

% section types_in_mics (end)

\input{chapters/6-micsimplementation/initializing-mics}

\input{chapters/6-micsimplementation/syntaxtreevalidation}

\section{Mapping to ScriptSharp AST} % (fold)
\label{sec:mapping_to_scriptsharp_ast}
	When converting the validated Roslyn AST to its corresponding ScriptSharp AST, a logical division of the process has been made. 

	\begin{itemize}
		\item Mapping a Roslyn AST node to its equivalent ScriptSharp AST node
		\item Building a ScriptSharp AST from all the mapped nodes
	\end{itemize}

	It is important to realize that the mapping is a sub process of the building process. The mapping is discussed in this section. 

	\subsection{Mapping to ScriptSharp Expressions, Statements and Symbols} % (fold)
	\label{sub:subsection_mapping_to_scriptsharp_expressions_statements_and_symbols}
		The mapping of Expressions, Statements and Symbols is implemented in three classes (ExpressionMapper.cs, StatementMapper.cs and SymbolMapper.cs). The three classes are logically divided (and named) after the kind of ScriptSharp AST node they map to. 

		\begin{figure}[H]
			\begin{center}
				\centerline{\includegraphics[width=14cm]{resources/images/MapperClasses.png}}
			\end{center}
			\caption{Classes that define extension methods for mapping Roslyn AST nodes to Script\# AST nodes.}
			\label{mapperClasses}
		\end{figure}

		TODO: Clarify this sentence

		The mapping of the AST nodes is somewhat straightforward as most of the mappings we have done the Roslyn AST maps one to one with the ScriptSharp AST. A Roslyn return statement node maps to a ScriptSharp return statement etc. The three classes define \texttt{Map(...)} extension methods to the Roslyn objects they map from (see example figures \ref{returnStatementMap} and \ref{conditionaleExpressionMap}).

		\begin{figure}[H]
			\begin{center}
				\centerline{\includegraphics[width=14cm]{resources/images/ReturnStatementMap.png}}
			\end{center}
			\caption{Extension method that maps Roslyn return statement to Script\# return statement.}
			\label{returnStatementMap}
		\end{figure}

		\begin{figure}[H]
			\begin{center}
				\centerline{\includegraphics[width=14cm]{resources/images/ConditionalExpressionMap.png}}
			\end{center}
			\caption{Extension method that maps Roslyn conditional expression to Script\# conditional expression.}
			\label{conditionaleExpressionMap}
		\end{figure}
	% subsection subsection_mapping_to_scriptsharp_expressions_statements_and_symbols (end)

	\subsection{Type Mapping} % (fold)
	\label{sub:type_mapping}
		Roslyn type symbols are mapped to Script\# type symbols using the SymbolMapper’s Map(...) extension method created for the Roslyn TypeSymbol. The mapping of TypeSymbols from Roslyn to Script\# can be somewhat confusing since there are the different kinds of types (illustrated in figure \ref{typesOverview}) and there are some special cases (such as null which is mapped to the type Object in JavaScript). To illustrate the functionality of the TypeSymbol Map(...) method we have created the flowchart in figure \ref{typeMappingFlowchart}.

			\begin{figure}
			\begin{center}
					\includegraphics[width=14cm]{resources/images/TypeMappingFlowchart.png}
					\end{center}
				\caption{Illustration of the type mapping process performed in SymbolMapper.Map(this TypeSymbol typeSymbol) extension method.}
				\label{typeMappingFlowchart}
			\end{figure}


		\subsubsection{Core Type Mapping} % (fold)
		\label{subsub:core:type_mapping}
			In contrast to using Script\# in the original manner (where the Script\# core types are used when writing code instead of the .NET core types) our project only uses the Script\# core types when mapping to the Script\# JavaScript AST. For this reason the Script\# core types are handled by its own type manager class (ScriptSharpTypeManager.cs). The Script\# core types’ source code are loaded into their own SemanticModel on the TypeManager class. From here the (Roslyn) types are retrieved before they are mapped to Script\# TypeSymbols needed when building the Script\# AST.

			Since the .NET core types are used when writing MiCS code and since these are mapped to the ScriptSharp core types a mapping specification is needed. To facilitate this mapping we have created some simple classes to hold the specification (MiCSCoreMapping.cs, MiCSCoreTypeMapping.cs and MiCSCoreMemberMapping.cs) which then can queried using LINQ. This mapping specification contains information on the core types that we currently support. So if a core type is not described in the specification then it is not supported. If the core type is found in the specification then the same pattern applies for its members. If a type member is not found then it is not supported. The mapping specification also holds information on a member’s return type, number of arguments and the arguments’ types.

			\begin{figure}[H]
					\includegraphics[width=8cm]{resources/images/InitiationOfTypeMapping.png}
				\caption{Instantiation example of a single core type (System.String) mapping specification.}
				\label{coreTypeMapping}
			\end{figure}

			An example of a core type mapping is the C\# System.String (see figure \ref{coreTypeMapping}) type which is mapped to the ScriptSharp defined System.String. We are only mapping two of the String type’s members. The field Length which is mapped to the ScriptSharp String type’s Length field (which is the equivalent of the JavaScript String object property length). The second member we map is the IndexOf(Char char) method that returns an int. There are other IndexOf methods that take multiple arguments or a single argument of a different type (than Char) but these are not mapped in our mapping specification.
		% subsection subsection_name (end)
	% subsection type_mapping (end)
% section mapping_to_scriptsharp_ast (end)

\section{Building the ScriptSharp AST} % (fold)
\label{sec:building_the_scriptsharp_ast}
	Building the Script\# AST consists of taking the mapped (Script\#) AST nodes and putting them together to form the Script\# AST. The builder classes uses the Roslyn infrastructure by extending the \texttt{SyntaxWalker} class which makes them capable of traversing the Roslyn AST.
	\begin{figure}[H]
		\begin{center}
			\centerline{\includegraphics[width=16cm]{resources/images/BuilderClasses.png}}
		\end{center}
		\caption{Classes that build the Script\# AST by traversing the Roslyn AST and using the Map(...) extension methods.}
		\label{builderClasses}
	\end{figure}

	The \texttt{NamespaceBuilder} class is responsible for building all of the types contained in a namespace. This is done by instantiating a \texttt{ClassBuilder} which in turn is responsible for building all of the member methods in a class (which is done using a \texttt{MethodBuilder}). This implies that the building of the Script\# AST is done in a depth first manner (the same way the Roslyn AST is traversed).  

	\begin{figure}[H]
		\begin{center}
			\centerline{\includegraphics[width=16cm]{resources/images/VisitClassDeclaration.png}}
		\end{center}
		\caption{Empty Script\# class is created and then built by using a \texttt{MethodBuilder} to retrieve all its member methods. The \texttt{ssClasses} property on the class builder holds all the classes that will be returned to the \texttt{NamespaceBuilder} who created it.}
		\label{visitClassDeclaration}
	\end{figure}

	The \texttt{NamespaceBuilder} and \texttt{ClassBuilder} classes are somewhat trivial. The \texttt{ClassBuilder} however ensures that DOM or core types are not be mapped to the Script\# as these types obviously already exists in JavaScript.

	The \texttt{MethodBuilder} class is a little more complex. It needs to build only the methods that are mixed side or client side methods. Furthermore it needs to handle a method’s return type, arguments and body statements. 

	Likewise the \texttt{StatementBuilder} and \texttt{ExpressionBuilder} are somewhat complex as building compound statements and expressions also bares some complexity. Before a compound statement or expression can be built all its child nodes and their associated types (if any) needs to be mapped.

	\begin{figure}[H]
		\begin{center}
			\centerline{\includegraphics[width=16cm]{resources/images/VisitIfStatement.png}}
		\end{center}
		\caption{To build an if-statement node its child nodes; condition, if-block and else-block (if any) has to be built first.}
		\label{visitIfStatement}
	\end{figure}

	When a builder class is done building the node(s) are returned to the parent builder class. Once all the namespaces has been built these constitute the Script\# AST which is then passed on in the overall workflow (to script generation).
% section building_the_scriptsharp_ast (end)

\section{Script Generation} % (fold)
\label{sec:script_generation}
	Script generation is done using the Script\# infrastructure only. Specifically the \texttt{TypeGenerator} class located in the \texttt{ScriptSharp.Generator} namespace is used for this. The \texttt{MiCSManager} is responsible for instantiating the \texttt{TypeGenerator} and providing it with types from the Script\# AST. This happens in the \texttt{MiCSManager.GenerateScriptText} method.
% section script_generation (end)

\section{Integration with Web Forms} % (fold)
\label{sec:integration_with_web_forms}
	Because of the time constraint on this project Integration with Web Forms has only received a minimum amount of time. We have ensured that we could implement our case study however there should be made substantial improvements to the Web Forms Integration code which we will discuss in section TODO: REF.

	However integration with Web Forms is currently done using the \texttt{MiCSPage} class. The \texttt{MiCSPage} class inherits from the \texttt{System.Web.UI.Page} class so that it’s possible to inherit from the \texttt{MiCSPage} class in one’s Code Behind file.  The \texttt{MiCSPage} class searches the specific project’s file structure for C\# files, reads their content and passes this content to the \texttt{MiCSManager} who then starts the entire MiCS workflow so that the client side script will be generated. The generated script is then registered with a \texttt{ScriptManager} which is how scripts are embedded into a page from Code Behind.

	Another important aspect of integration with Web Forms is how the generated client side scripts are initially called. Client side scripts are usually initiated through DOM events such as \texttt{onload} and \texttt{onclick} which are triggered when a web page is loaded and when a button is clicked respectively. MiCS currently only supports registering a client side method on a buttons click event using our extension method \texttt{OnClientClick(…)}.

% section integration_with_web_forms (end)
