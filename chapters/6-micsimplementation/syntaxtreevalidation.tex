\section{Validating Mixed and Client Side Code} % (fold)
\label{sec:syntax_tree_validation}
	% As we only support a fairly limited set of C\#’s built-in constructs and types, it is important to make sure that users only make use of those that we are able to map to Script\#. Should users utilise one of the constructs or types that we are not able to map, this should be pointed out with an understandable error message. It should not be left to the users to debug or understand a Roslyn or Script\# exception. Furthermore, it is important to make sure that users use their own code correctly. The remainder of this section will describe how a Validator class is used to achieve this.

	Before the Roslyn AST is mapped to Script\# it is necessary to verify that types and their members are used correcly. This is handled by the \texttt{Validator} class. If the developer only uses .NET types that we can map to ScriptSharp and adhere to the Mixed Side Principle, the validation passes. The remainder of this section focus on how this validation is done.
	%Understanding “correct usage of .NET built-in types and members” is straightforward; it means that users are only allowed to use the types and members that can be mapped correctly to Script\#. How this is achieved is described later in this section. However, “correct usage of the types defined by the users themselves” requires some explanation. For this, the MixedSide Principle is introduced.

%To explain correct usage of types and their members, it is beneficial to divide them into two categories; types that are built into the .NET platform and types developers define themselves.



There are essentially three situations in which it is necessary to verify correct usage of types and members.

\begin{itemize}
	\item Object creation; when an instance of a type is created, it is necessary to check the type in question can be mapped.
	\item When members on type instances are accessed; it is then necessary to check first if the type can be mapped, then if the type has a member corresponding to the one being accessed.
	\item Invocation of methods on .NET core types; it is then necessary to check whether the invocation is done correctly, using the correct arguments and return type. Normally, the C\# compiler complains if an invocation is done using an incorrect signature, but as the interface between .NET core types and Script\# core types does not always match, it is important to make sure that the Script\# core type has a member with the corresponding arguments and return type. An invocation that is perfectly legal on .NET core types might be illegal on Script\# core types.
\end{itemize}

The Validator class extends Roslyn's SyntaxWalker class and it is thus able to traverse syntax nodes. The Validator takes a CompilationUnit which holds the code to be validated, a string containing an attribute name (''MixedSide'' or ''ClientSide'') that decides what methods to validate, and a structure of types and members that the validated methods are allowed to use. This structure of members has been built by a \texttt{Collector} class which traverses the Roslyn AST and collects all MixedSide and ClientSide members.
It works by looking for classes in the CompilationUnit that contains methods annotated with the given attribute name and validates the body of these methods against the provided structure of members.

The nature of the Validator requires the Syntax Tree to be validated twice. Once validating all the MixedSide methods against a structure containing all MixedSide types and their members, and once validating all the ClientSide methods against a structure containing all ClientSide types and members, MixedSide types and members and ScriptSharp DOM types and members. This is done by creating two instances of the Validator and validating them both.

The Validation process is best explained by looking at an example. Consider the situation showed in Figure \ref{fig:mixedSideValidationExample}. 

\begin{figure}[H]
	\begin{center}
		\centerline{\includegraphics[width=14cm]{resources/images/MixedSideValidationExample.png}}
	\end{center}
	\caption{TODO: Update example so that Validator is not used as example class}
	\label{fig:mixedSideValidationExample}
\end{figure}		

The Validator traverses the CompilationUnit depth-first and discovers the Validator class. It then finds all of the Validator class's methods and checks if they have the MixedSide attribute. When a method annotated with the MixedSide attribute is found, the validator visits it straight away, as shown in Figure \ref{fig:ValidatorVisitClassDeclaration}. 

\begin{figure}[H]
	\begin{center}
		\centerline{\includegraphics[width=14cm]{resources/images/ValidatorVisitClassDeclaration.png}}
	\end{center}
	\caption{Visiting a ClassDeclaration and deciding whether its methods should be validated or not}
	\label{fig:ValidatorVisitClassDeclaration}
\end{figure}

The first method visited is the \texttt{IsStringValid()} method. The first statement of the method contains an object creation expression and the Validator now needs to check if the object creation is legal. It is legal either if the created object is a supported core type, or if the object is a user defined MixedSide type (residing within the members structure). As the type exists in the allowed members structure (shown in figure \ref{fig:mixedSideValidationExample}) the object creation is legal and the traversal continues. If it had not existed in the allowed member structure (this could happen if it had been ClientSide), and had not been a supported core type, the MixedSide Principle would have been violated, and an exception of type \texttt{MixedSidePrincipleViolatedException} had been thrown.

The validation of a member access is done in a very similar way, only checking if the member exists in the allowed-members structure or in the core mapping as well.

As mentioned earlier, it is important to validate invocation on core types. This is done using the \texttt{VerifyCorrectUseOfSupportedCoreType} method on the \texttt{TypeManager}. This method first checks if the given invocation is done on a core type, and subsequently uses the Core Mapping Specification (as discussed in section \ref{sub:type_mapping}) to verify that we are able to map the invocation to ScriptSharp.
		



		% When an invocation is visited, the \texttt{TypeManager} is asked to 
		% TODO: Write about how invociations are validated: Only core types need to be validated (with arguments and return types), as user types will automatically be validated by the compiler.


% \begin{lstlisting}[language=CSharp,classoffset=1,morekeywords={TextBox,Panel,CheckBox, Button}]
% TextBox NameBox = new TextBox() { ID = "name", Text = "Name" };
% Panel CheckBoxGroup = new Panel();
% CheckBox SnailMailCheck = new CheckBox() { ID = "dmSnailmail", Text = "Snail Mail" };
% CheckBox EmailCheck = new CheckBox() { ID = "dmEmail", Text = "E-Mail" };
% TextBox AddressBox = new TextBox() { ID = "address", Text = "Address" };
% TextBox ZipcodeBox = new TextBox() { ID = "zipcode", Text = "Zip Code" };
% TextBox EmailBox = new TextBox() { ID = "email", Text = "E-mail" };
% TextBox PhoneBox = new TextBox() { ID = "phone", Text = "Phone" };
% Button SubmitButton = new Button() { Text = "Register" };
% \end{lstlisting}






	
	% subsection validating (end)
% section syntax_tree_validation (end)